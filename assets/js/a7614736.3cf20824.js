"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[729],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return u}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var m=a.createContext({}),s=function(e){var n=a.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(m.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(t),u=r,h=d["".concat(m,".").concat(u)]||d[u]||c[u]||i;return t?a.createElement(h,o(o({ref:n},p),{},{components:t})):a.createElement(h,o({ref:n},p))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var m in n)hasOwnProperty.call(n,m)&&(l[m]=n[m]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3106:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},metadata:function(){return m},toc:function(){return s},default:function(){return c}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),o=["components"],l={title:"Input tokenization"},m={unversionedId:"command-extension/input-tokenization",id:"command-extension/input-tokenization",isDocsHomePage:!1,title:"Input tokenization",description:'As for the majority of command-based user interfaces, a command may accept some user input, often called "arguments", to specify parameters for a specific action. The simplest commands can be run as-is, while more complex ones may require several arguments with some possibly being optional. Parsing the input, checking if required arguments are present, are of the correct format, etc can represent a lot of work when implementing such complex commands, and ends up being repetitive. The command extension of Botrino can do most of that boring work for you.',source:"@site/docs/command-extension/input-tokenization.md",sourceDirName:"command-extension",slug:"/command-extension/input-tokenization",permalink:"/docs/command-extension/input-tokenization",editUrl:"https://github.com/Alex1304/botrino/edit/main/website/docs/command-extension/input-tokenization.md",version:"current",frontMatter:{title:"Input tokenization"},sidebar:"someSidebar",previous:{title:"Creating commands",permalink:"/docs/command-extension/creating-commands"},next:{title:"Subcommands",permalink:"/docs/command-extension/subcommands"}},s=[{value:"Tokenization",id:"tokenization",children:[{value:"Arguments",id:"arguments",children:[]},{value:"Flags",id:"flags",children:[]}]},{value:"Grammar",id:"grammar",children:[]}],p={toc:s};function c(e){var n=e.components,t=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,'As for the majority of command-based user interfaces, a command may accept some user input, often called "arguments", to specify parameters for a specific action. The simplest commands can be run as-is, while more complex ones may require several arguments with some possibly being optional. Parsing the input, checking if required arguments are present, are of the correct format, etc can represent a lot of work when implementing such complex commands, and ends up being repetitive. The command extension of Botrino can do most of that boring work for you.'),(0,i.kt)("h2",{id:"tokenization"},"Tokenization"),(0,i.kt)("p",null,'When a message create event is received from Discord, the content of the message is interpreted in order to find the corresponding command. It will split the message content into "words", stripping out the prefix, will match the first "word" with a command name and will process the remaining "words" into ',(0,i.kt)("strong",{parentName:"p"},"arguments")," and ",(0,i.kt)("strong",{parentName:"p"},"flags"),". This process is called ",(0,i.kt)("strong",{parentName:"p"},"input tokenization"),"."),(0,i.kt)("h3",{id:"arguments"},"Arguments"),(0,i.kt)("p",null,"An argument is a substring of the message content that is delimited with whitespaces and that comes after the command name. A simple example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"!hello world\n")),(0,i.kt)("p",null,"Here the command name is ",(0,i.kt)("inlineCode",{parentName:"p"},"hello"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"world")," is an argument."),(0,i.kt)("p",null,"You can access the list of arguments via ",(0,i.kt)("inlineCode",{parentName:"p"},"CommandContext.input().getArguments()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"@Override\npublic Mono<Void> run(CommandContext ctx) {\n    List<String> args = ctx.input().getArguments();\n    return ctx.channel().createMessage(args.toString()).then();\n}\n")),(0,i.kt)("p",null,"If this was the implementation of the previous example, it would send ",(0,i.kt)("inlineCode",{parentName:"p"},"[world]")," in the Discord channel (the ",(0,i.kt)("inlineCode",{parentName:"p"},"toString()")," representation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," of arguments). Another example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"!hello foo bar\n")),(0,i.kt)("p",null,"would reply with ",(0,i.kt)("inlineCode",{parentName:"p"},"[foo, bar]"),", etc."),(0,i.kt)("p",null,"It is possible to put spaces into a single argument if it is delimited with double quotes (",(0,i.kt)("inlineCode",{parentName:"p"},'"'),"). As such, the example below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'!hello "foo bar"\n')),(0,i.kt)("p",null,"would return a list of ",(0,i.kt)("strong",{parentName:"p"},"one")," element which is the string ",(0,i.kt)("inlineCode",{parentName:"p"},"foo bar"),"."),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"This implies that the double quote character is reserved and should be escaped with ",(0,i.kt)("inlineCode",{parentName:"p"},"\\")," if you want to use it in an argument value, same for the ",(0,i.kt)("inlineCode",{parentName:"p"},"\\")," character itself. See the table below that illustrates that."))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"input"),(0,i.kt)("th",{parentName:"tr",align:null},"output"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'!hello "foo bar"')),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"[foo bar]"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'!hello \\"foo bar\\"')),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'["foo, bar"]'))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"!hello fo\\\\o ba\\\\r")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"[fo\\o, ba\\r]"))))),(0,i.kt)("h3",{id:"flags"},"Flags"),(0,i.kt)("p",null,"Flags are similar to arguments, except they are ",(0,i.kt)("strong",{parentName:"p"},"named")," and are ",(0,i.kt)("strong",{parentName:"p"},"position-independent"),". A flag is distinguished from an argument by a dash (",(0,i.kt)("inlineCode",{parentName:"p"},"-"),") prefix."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"!hello -a world\n")),(0,i.kt)("p",null,"In the example above, there is ",(0,i.kt)("strong",{parentName:"p"},"only one")," argument, ",(0,i.kt)("inlineCode",{parentName:"p"},"world"),". Indeed, ",(0,i.kt)("inlineCode",{parentName:"p"},"-a")," isn't an argument but a ",(0,i.kt)("strong",{parentName:"p"},"flag"),", due to the presence of the ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," prefix. In the code of the command, you can access a flag like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'@Override\npublic Mono<Void> run(CommandContext ctx) {\n    String message;\n    if (ctx.input().getFlag("a").isPresent()) {\n        message = "The flag is present";\n    } else {\n        message = "The flag isn\'t present";\n    }\n    return ctx.channel().createMessage(message).then();\n}\n')),(0,i.kt)("p",null,"You must not write the ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," prefix in the argument of ",(0,i.kt)("inlineCode",{parentName:"p"},"getFlag()"),". It returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional<String>")," that is empty if the flag is not present in the message. The position-independent nature of flags implies that ",(0,i.kt)("inlineCode",{parentName:"p"},"!hello -a world")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!hello world -a")," are strictly equivalent. Even something like ",(0,i.kt)("inlineCode",{parentName:"p"},"!-a hello world")," will work. If the flag is present, it will return an empty ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),", unless a specific value is passed like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"!hello -a=foo world\n")),(0,i.kt)("p",null,"In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},'getFlag("a")')," would return an ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional")," containing the string ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),". Here is a table to summarize:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"input"),(0,i.kt)("th",{parentName:"tr",align:null},"result of ",(0,i.kt)("inlineCode",{parentName:"th"},'ctx.input().getFlag("a")')))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"!hello")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Optional.empty()"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"!hello -a")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'Optional.of("")'))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"!hello -a=foo")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'Optional.of("foo")'))))),(0,i.kt)("h2",{id:"grammar"},"Grammar"),(0,i.kt)("p",null,"The fact that tokenization is done for you is a great thing, but that's only a part of the work. When you access the value of an argument, you still need to interpret it, and possibly do some type conversion and validation work on it."),(0,i.kt)("p",null,"Let's take a simple example. You want to create a command that allows to rename a channel in a guild. The most intuitive way to design the command is to do something like ",(0,i.kt)("inlineCode",{parentName:"p"},"!rename <channel> <new_name>"),". The second argument is just a string so it won't be too much of an issue, however the first argument must be interpreted as an existing Discord channel in the current guild first."),(0,i.kt)("p",null,"With what you know already, you can implement that command as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'package com.example.myproject;\n\nimport botrino.api.util.DiscordParser;\nimport botrino.api.util.MatcherFunction;\nimport botrino.command.Command;\nimport botrino.command.CommandContext;\nimport botrino.command.CommandFailedException;\nimport botrino.command.Scope;\nimport botrino.command.annotation.Alias;\nimport botrino.command.annotation.TopLevelCommand;\nimport discord4j.core.object.entity.channel.*;\nimport reactor.core.publisher.Mono;\n\n@Alias("rename")\n@TopLevelCommand\npublic final class RenameCommand implements Command {\n\n    @Override\n    public Mono<Void> run(CommandContext ctx) {\n        var args = ctx.input().getArguments();\n        if (args.size() < 2) {\n            return Mono.error(new CommandFailedException("Expected 2 arguments"));\n        }\n        var gateway = ctx.event().getClient();\n        var guildId = ctx.event().getGuildId().orElseThrow(); // Never throws because we set Scope.GUILD_ONLY\n        var channelMono = DiscordParser.parseGuildChannel(gateway, guildId, args.get(0));\n        var newName = args.get(1);\n        return channelMono\n                .flatMap(channel -> MatcherFunction.<Mono<? extends GuildChannel>>create()\n                        .matchType(TextChannel.class, ch -> ch.edit(spec -> spec.setName(newName)))\n                        .matchType(NewsChannel.class, ch -> ch.edit(spec -> spec.setName(newName)))\n                        .matchType(StoreChannel.class, ch -> ch.edit(spec -> spec.setName(newName)))\n                        .matchType(VoiceChannel.class, ch -> ch.edit(spec -> spec.setName(newName)))\n                        .apply(channel)\n                        .orElseGet(() -> Mono.error(new CommandFailedException("Unknown channel type"))))\n                .then(ctx.channel().createMessage("Successfully renamed channel"))\n                .then();\n    }\n\n    @Override\n    public Scope scope() {\n        return Scope.GUILD_ONLY;\n    }\n}\n')),(0,i.kt)("p",null,"Since this example is simple enough, the ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," method is only 18 lines long, so it's not that bad. But you can notice that 8 of those lines only consist of parsing the arguments, the core logic of the method resides in the last 10 lines. You can imagine for more complex commands with many arguments that the first part can be heavy and repetitive. This is the problematic ",(0,i.kt)("strong",{parentName:"p"},"command grammars")," bring a solution to."),(0,i.kt)("p",null,"With a grammar, you can completely get rid of the code that handles arguments, so that your ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," method is effectively focused on its core logic:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'package com.example.myproject;\n\nimport botrino.api.util.MatcherFunction;\nimport botrino.command.Command;\nimport botrino.command.CommandContext;\nimport botrino.command.CommandFailedException;\nimport botrino.command.Scope;\nimport botrino.command.annotation.Alias;\nimport botrino.command.annotation.TopLevelCommand;\nimport botrino.command.grammar.ArgumentMapper;\nimport botrino.command.grammar.CommandGrammar;\nimport discord4j.core.object.entity.channel.*;\nimport reactor.core.publisher.Mono;\n\n@Alias("rename")\n@TopLevelCommand\npublic final class RenameCommand implements Command {\n\n    private final CommandGrammar<Args> grammar = CommandGrammar.builder() // Step 2\n            .nextArgument("channel", ArgumentMapper.asGuildChannel())\n            .nextArgument("newName")\n            .build(Args.class);\n\n    @Override\n    public Mono<Void> run(CommandContext ctx) {\n        return grammar.resolve(ctx) // Step 3\n                .flatMap(args -> MatcherFunction.<Mono<? extends GuildChannel>>create()\n                        .matchType(TextChannel.class, ch -> ch.edit(spec -> spec.setName(args.newName)))\n                        .matchType(NewsChannel.class, ch -> ch.edit(spec -> spec.setName(args.newName)))\n                        .matchType(StoreChannel.class, ch -> ch.edit(spec -> spec.setName(args.newName)))\n                        .matchType(VoiceChannel.class, ch -> ch.edit(spec -> spec.setName(args.newName)))\n                        .apply(args.channel)\n                        .orElseGet(() -> Mono.error(new CommandFailedException("Unknown channel type"))))\n                .then(ctx.channel().createMessage("Successfully renamed channel"))\n                .then();\n    }\n\n    @Override\n    public Scope scope() {\n        return Scope.GUILD_ONLY;\n    }\n\n    private static final class Args { // Step 1\n        private GuildChannel channel;\n        private String newName;\n    }\n}\n')),(0,i.kt)("p",null,"Creating a grammar is done in 3 steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Declare an ",(0,i.kt)("strong",{parentName:"li"},"internal class")," with fields corresponding to arguments with their correct type."),(0,i.kt)("li",{parentName:"ol"},"Build a ",(0,i.kt)("inlineCode",{parentName:"li"},"CommandGrammar")," instance describing the sequence of arguments accepted by your command. The ",(0,i.kt)("inlineCode",{parentName:"li"},"nextArgument")," method allows you to specify the name of the field of the internal class to bind, with an ",(0,i.kt)("inlineCode",{parentName:"li"},"ArgumentMapper")," if the target type is something else than ",(0,i.kt)("inlineCode",{parentName:"li"},"String"),". Think of ",(0,i.kt)("inlineCode",{parentName:"li"},"ArgumentMapper")," like a ",(0,i.kt)("inlineCode",{parentName:"li"},"BiFunction<CommandContext, String, T>")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," is the target type. The most common types are present as a static factory in ",(0,i.kt)("inlineCode",{parentName:"li"},"ArgumentMapper"),", but you can implement your own with a lambda expression. The order in which ",(0,i.kt)("inlineCode",{parentName:"li"},"nextArgument")," calls are made is important as it will determine if the command should be ",(0,i.kt)("inlineCode",{parentName:"li"},"!rename <channel> <newName>")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"!rename <newName> <channel>"),"."),(0,i.kt)("li",{parentName:"ol"},"In your ",(0,i.kt)("inlineCode",{parentName:"li"},"run")," method, all you need to do is to call ",(0,i.kt)("inlineCode",{parentName:"li"},"grammar.resolve(CommandContext)")," to get an instance of your internal class with all arguments filled. In this case it will automatically emit ",(0,i.kt)("inlineCode",{parentName:"li"},"InvalidSyntaxException")," if the arguments are missing, because all arguments are required by default.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"CommandGrammar.Builder")," class has additional features allowing you to configure ",(0,i.kt)("strong",{parentName:"p"},"optional")," and ",(0,i.kt)("strong",{parentName:"p"},"varying")," arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Example 1: foo is required, bar is optional"',title:'"Example',"1:":!0,foo:!0,is:!0,"required,":!0,bar:!0,'optional"':!0},'CommandGrammar.builder()\n        .nextArgument("foo")\n        .beginOptionalArguments()\n        .nextArgument("bar")\n        .build(Args.class);\n\nprivate static final class Args {\n    private String foo; // Cannot be null\n    private String bar; // Can be null\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Example 2: both foo and bar are optional"',title:'"Example',"2:":!0,both:!0,foo:!0,and:!0,bar:!0,are:!0,'optional"':!0},'CommandGrammar.builder()\n        .beginOptionalArguments()\n        .nextArgument("foo")\n        .nextArgument("bar", ArgumentMapper.asInteger())\n        .build(Args.class);\n\nprivate static final class Args {\n    private String foo; // Can be null\n    private Integer bar; // Can be null, so must be of type Integer (and not int)\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Example 3: bar can be repeated zero, one or multiple times"',title:'"Example',"3:":!0,bar:!0,can:!0,be:!0,repeated:!0,"zero,":!0,one:!0,or:!0,multiple:!0,'times"':!0},'CommandGrammar.builder()\n        .nextArgument("foo")\n        .nextArgument("bar", ArgumentMapper.asInteger())\n        .setVarargs(true)\n        .build(Args.class);\n\nprivate static final class Args {\n    private String foo; // Cannot be null\n    private List<Integer> bar; // Must be a List of the target type, can be empty\n}\n')),(0,i.kt)("p",null,"A few things to note:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If an optional argument is not provided, the corresponding field in the internal class will be filled with ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),". It means that for primitive types you need to use the wrapper type for the field type (",(0,i.kt)("inlineCode",{parentName:"li"},"java.lang.Integer")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"int"),", etc) otherwise you will experience ",(0,i.kt)("inlineCode",{parentName:"li"},"NullPointerException"),"."),(0,i.kt)("li",{parentName:"ul"},"Optional arguments can only be at the end, hence ",(0,i.kt)("inlineCode",{parentName:"li"},"beginOptionalArguments()")," which separates required from optional arguments."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"setVarargs(true)")," is the only method that is insensitive to its position in the chain: it only applies to the very last argument."),(0,i.kt)("li",{parentName:"ul"},"A varying argument is materialized with a field of type ",(0,i.kt)("inlineCode",{parentName:"li"},"java.util.List")," in the internal class, and is always optional even if ",(0,i.kt)("inlineCode",{parentName:"li"},"beginOptionalArguments()")," was never called (in which case the list will be empty).")),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The Command Grammar API does not support flags at this moment, only regular arguments. Feel free to suggest it or open a PR in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Alex1304/botrino"},"GitHub repository")," if you have improvement ideas."))))}c.isMDXComponent=!0}}]);