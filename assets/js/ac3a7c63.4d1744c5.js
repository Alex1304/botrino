"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[756],{5329:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=i(4848),o=i(8453);const s={title:"Extensions"},r=void 0,a={id:"api/extensions",title:"Extensions",description:"When you start your application, Botrino automatically loads all the classes present in bot modules. According to the",source:"@site/docs/api/extensions.mdx",sourceDirName:"api",slug:"/api/extensions",permalink:"/docs/api/extensions",draft:!1,unlisted:!1,editUrl:"https://github.com/Alex1304/botrino/edit/main/website/docs/api/extensions.mdx",tags:[],version:"current",frontMatter:{title:"Extensions"},sidebar:"someSidebar",previous:{title:"Customizing the Discord client",permalink:"/docs/api/customizing-the-discord-client"},next:{title:"Internationalization",permalink:"/docs/api/i18n"}},c={},d=[{value:"Declaring an extension",id:"declaring-an-extension",level:2},{value:"Implementing an extension",id:"implementing-an-extension",level:2},{value:"<code>void onClassDiscovered(Class&lt;?&gt; clazz)</code>",id:"void-onclassdiscoveredclass-clazz",level:3},{value:"<code>void onServiceCreated(Object o)</code>",id:"void-onservicecreatedobject-o",level:3},{value:"<code>Set&lt;ServiceDescriptor&gt; provideExtraServices()</code>",id:"setservicedescriptor-provideextraservices",level:3},{value:"<code>Set&lt;Class&lt;?&gt;&gt; provideExtraDiscoverableClasses()</code>",id:"setclass-provideextradiscoverableclasses",level:3},{value:"<code>Mono&lt;Void&gt; finishAndJoin()</code>",id:"monovoid-finishandjoin",level:3},{value:"A concrete example: the interaction library",id:"a-concrete-example-the-interaction-library",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"When you start your application, Botrino automatically loads all the classes present in bot modules. According to the\ntype of classes that are discovered, an action will be performed on them such as registering a service or adding a\nconfiguration entry. Extensions allow you to hook into this module scanning process to add your own logic when classes\nare loaded."}),"\n",(0,t.jsx)(n.h2,{id:"declaring-an-extension",children:"Declaring an extension"}),"\n",(0,t.jsxs)(n.p,{children:["Unlike other components of the framework, extensions do not need to reside in a module annotated with ",(0,t.jsx)(n.code,{children:"@BotModule"}),".\nThink of extensions like plugins for the framework itself and not for your bot application directly. Your module does\nnot need to be ",(0,t.jsx)(n.code,{children:"open"})," either, extensions are loaded\nvia  ",(0,t.jsx)(n.a,{href:"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html",children:(0,t.jsx)(n.code,{children:"java.util.ServiceLoader"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The first step is to create a class implementing the ",(0,t.jsx)(n.code,{children:"BotrinoExtension"})," interface:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"package com.example.myproject;\n\nimport botrino.api.extension.BotrinoExtension;\nimport com.github.alex1304.rdi.config.ServiceDescriptor;\nimport reactor.core.publisher.Mono;\n\nimport java.util.Set;\n\npublic final class MyExtension implements BotrinoExtension {\n\n    @Override\n    public void onClassDiscovered(Class<?> clazz) {\n        // ...\n    }\n\n    @Override\n    public void onServiceCreated(Object o) {\n        // ...\n    }\n\n    @Override\n    public Set<ServiceDescriptor> provideExtraServices() {\n        // ...\n    }\n\n    @Override\n    public Set<Class<?>> provideExtraDiscoverableClasses() {\n        // ...\n    }\n\n    @Override\n    public Mono<Void> finishAndJoin() {\n        // ...\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Before going into the details of the methods to implement, let's register this class as a provider\nfor ",(0,t.jsx)(n.code,{children:"BotrinoExtension"}),". This is done via the ",(0,t.jsx)(n.code,{children:"module-info.java"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import botrino.api.extension.BotrinoExtension;\nimport com.example.extension.MyExtension;\n\nmodule com.example.extension {\n\n    requires botrino.api;\n    provides BotrinoExtension with MyExtension;\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["You don't ",(0,t.jsx)(n.em,{children:"have"})," to create a separate module just for your extension. It is totally fine to add the ",(0,t.jsx)(n.code,{children:"provides"})," directive\ndirectly in your ",(0,t.jsx)(n.code,{children:"@BotModule"}),", this example just shows that you are not required to."]})}),"\n",(0,t.jsx)(n.h2,{id:"implementing-an-extension",children:"Implementing an extension"}),"\n",(0,t.jsxs)(n.p,{children:["Let's review each of the methods of ",(0,t.jsx)(n.code,{children:"BotrinoExtension"})," to implement."]}),"\n",(0,t.jsx)(n.h3,{id:"void-onclassdiscoveredclass-clazz",children:(0,t.jsx)(n.code,{children:"void onClassDiscovered(Class<?> clazz)"})}),"\n",(0,t.jsx)(n.p,{children:"This is a callback method invoked each time a class is discovered in a bot module. In most cases, you will check if this\nclass implements a specific interface or is annotated with a specific annotation, and do some processing when it is\nrelevant to do so."}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["If you intend to create an instance of the class, it is highly recommended to skip classes annotated with ",(0,t.jsx)(n.code,{children:"@RdiService"}),"\nfrom this method, as they are supposed to be instantiated by the RDI container. That's why\nthe ",(0,t.jsx)(n.code,{children:"onServiceCreated(Object)"})," method exists."]})}),"\n",(0,t.jsx)(n.h3,{id:"void-onservicecreatedobject-o",children:(0,t.jsx)(n.code,{children:"void onServiceCreated(Object o)"})}),"\n",(0,t.jsx)(n.p,{children:"This is a callback method invoked each time a service is created. It allows to execute some action on the service object\nright after it's created."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["As this method returns ",(0,t.jsx)(n.code,{children:"void"}),", it is not suited for performing reactive tasks. Instead, store the service object in a\nfield and perform this task in ",(0,t.jsx)(n.code,{children:"finishAndJoin()"}),"."]})}),"\n",(0,t.jsx)(n.h3,{id:"setservicedescriptor-provideextraservices",children:(0,t.jsx)(n.code,{children:"Set<ServiceDescriptor> provideExtraServices()"})}),"\n",(0,t.jsxs)(n.p,{children:["Even though the extension may not be inside a bot module, it is still possible to register services that will be exposed\nto the bot application. You can do so via this method, allowing you to provide a set\nof ",(0,t.jsx)(n.a,{href:"https://alex1304.github.io/rdi/docs/service-descriptors",children:"RDI service descriptors"}),". This method is only useful if you\nwant to provide complex services that require writing raw descriptors (for example registering a class from a\nthird-party library as a service with a custom name). For simple services maintained by yourself, you can use RDI\nannotations and make the annotated class discoverable via ",(0,t.jsx)(n.code,{children:"provideExtraDiscoverableClasses()"})," instead of doing it via\nthis method."]}),"\n",(0,t.jsx)(n.h3,{id:"setclass-provideextradiscoverableclasses",children:(0,t.jsx)(n.code,{children:"Set<Class<?>> provideExtraDiscoverableClasses()"})}),"\n",(0,t.jsxs)(n.p,{children:["With this method you can explicitly specify a set of classes that Botrino will pick up just like if they were inside a\nbot module. It is guaranteed that each class contained in the set will eventually be passed to\nthe ",(0,t.jsx)(n.code,{children:"onClassDiscovered(Class)"})," method (unless they have the ",(0,t.jsx)(n.code,{children:"@Exclude"})," annotation). As said earlier, it can be used as\nan alternative way to provide extra services, if the class contained in the set is annotated with RDI annotations. It\ncan also be used to register new configuration entries, or new things you're defining yourself in your own extension!"]}),"\n",(0,t.jsx)(n.h3,{id:"monovoid-finishandjoin",children:(0,t.jsx)(n.code,{children:"Mono<Void> finishAndJoin()"})}),"\n",(0,t.jsxs)(n.p,{children:["This is the last method that is invoked during the startup sequence. It allows you to perform a task, possibly reactive,\nbased on the classes and objects you were able to collect via previous invocations of ",(0,t.jsx)(n.code,{children:"onClassDiscovered(Class)"}),"\nand ",(0,t.jsx)(n.code,{children:"onServiceCreated(Object)"}),'. The "join" part of this method\'s name indicates the fact that the returned reactive\nsequence does not need to be a finite source: you can use it to start processes living during the entire lifetime of the\napplication, for example installing event listeners or starting a web server. The subscription to the returned ',(0,t.jsx)(n.code,{children:"Mono"})," is\nautomatically cancelled once the bot disconnects, allowing the application to shut down properly."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["If an exception is thrown or an error is emitted via the ",(0,t.jsx)(n.code,{children:"Mono"})," from this method, the exception will propagate to the\nmain thread, which will result in the bot to forcefully disconnect and the application to be terminated."]})}),"\n",(0,t.jsx)(n.h2,{id:"a-concrete-example-the-interaction-library",children:"A concrete example: the interaction library"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"/docs/interaction-library/overview",children:"interaction library"})," of Botrino provides an implementation\nof ",(0,t.jsx)(n.code,{children:"BotrinoExtension"}),", which is in charge of collecting the classes\nimplementing ",(0,t.jsx)(n.code,{children:"XxxInteractionListener"}),", ",(0,t.jsx)(n.code,{children:"InteractionErrorHandler"}),", ",(0,t.jsx)(n.code,{children:"InteractionEventProcessor"})," and so on, in order to\nregister them in the ",(0,t.jsx)(n.code,{children:"InteractionService"}),". It also exposes a new entry in ",(0,t.jsx)(n.code,{children:"config.json"})," that allows to construct\nthe ",(0,t.jsx)(n.a,{href:"/docs/interaction-library/configuration",children:"configuration"})," object."]}),"\n",(0,t.jsxs)(n.p,{children:["You can check the source code of the extension class of the interaction library on\nGitHub ",(0,t.jsx)(n.a,{href:"https://github.com/Alex1304/botrino/blob/main/interaction/src/main/java/botrino/interaction/InteractionExtension.java",children:"here"}),".\nA few things to note to understand the code:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Classes with the ",(0,t.jsx)(n.code,{children:"@RdiService"})," annotation are ignored, since we want to use the instance created by RDI in\ncase ",(0,t.jsx)(n.code,{children:"XxxInteractionListener"}),", ",(0,t.jsx)(n.code,{children:"InteractionErrorHandler"})," and ",(0,t.jsx)(n.code,{children:"InteractionEventProcessor"})," are declared as services."]}),"\n",(0,t.jsxs)(n.li,{children:["An ",(0,t.jsx)(n.code,{children:"InstanceCache"})," is used so that the same instance can be reused in case a class implements more than one interface."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InteractionService"})," utilizes RDI annotations, so we provide it via ",(0,t.jsx)(n.code,{children:"provideExtraDiscoverableClasses()"})," and\nnot ",(0,t.jsx)(n.code,{children:"provideExtraServices()"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["All implementations that were found are finally registered in the ",(0,t.jsx)(n.code,{children:"finishAndJoin()"})," method, which runs the interaction\nservice at the end."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);