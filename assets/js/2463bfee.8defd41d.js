"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[510],{533:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var i=t(4848),o=t(8453);const a={title:"Creating commands"},r=void 0,s={id:"interaction-library/creating-commands",title:"Creating commands",description:"Commands represent the main form of interaction that Discord bots have with users. Creating commands is a simple and",source:"@site/docs/interaction-library/creating-commands.mdx",sourceDirName:"interaction-library",slug:"/interaction-library/creating-commands",permalink:"/docs/interaction-library/creating-commands",draft:!1,unlisted:!1,editUrl:"https://github.com/Alex1304/botrino/edit/main/website/docs/interaction-library/creating-commands.mdx",tags:[],version:"current",frontMatter:{title:"Creating commands"},sidebar:"someSidebar",previous:{title:"Configuration",permalink:"/docs/interaction-library/configuration"},next:{title:"Acknowledging interactions",permalink:"/docs/interaction-library/acknowledging-interactions"}},c={},d=[{value:"Chat input (aka &quot;slash&quot;) commands",id:"chat-input-aka-slash-commands",level:2},{value:"Basic command",id:"basic-command",level:3},{value:"Command options",id:"command-options",level:3},{value:"Subcommands and subcommand groups",id:"subcommands-and-subcommand-groups",level:3},{value:"Context menu commands",id:"context-menu-commands",level:2},{value:"Commands as a service",id:"commands-as-a-service",level:2}];function l(n){const e={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"Commands represent the main form of interaction that Discord bots have with users. Creating commands is a simple and\nstraightforward process, with the ability to customize different aspects of them."}),"\n",(0,i.jsx)(e.h2,{id:"chat-input-aka-slash-commands",children:'Chat input (aka "slash") commands'}),"\n",(0,i.jsx)(e.h3,{id:"basic-command",children:"Basic command"}),"\n",(0,i.jsxs)(e.p,{children:["A slash command is a command that is triggered when the user sends ",(0,i.jsx)(e.code,{children:"/command-name"}),' in chat. In the library, they are\ncalled "chat input commands".']}),"\n",(0,i.jsxs)(e.p,{children:["Here is an example of a ",(0,i.jsx)(e.code,{children:"/ping"}),' command that makes the bot reply with "Pong!":']}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.ChatInputCommand;\nimport botrino.interaction.listener.ChatInputInteractionListener;\nimport botrino.interaction.context.ChatInputInteractionContext;\nimport org.reactivestreams.Publisher;\n\n@ChatInputCommand(name = "ping", description = "Pings the bot to check if it is alive.")\npublic final class PingCommand implements ChatInputInteractionListener {\n\n    @Override\n    public Publisher<?> run(ChatInputInteractionContext ctx) {\n        return ctx.event().createFollowup("Pong!");\n    }\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["A chat input command must have a ",(0,i.jsx)(e.code,{children:"@ChatInputCommand"})," annotation that contains the meta-information required by\nDiscord (name of the command, description, defaultPermission, etc), and must implement\nthe ",(0,i.jsx)(e.code,{children:"ChatInputInteractionListener"})," interface."]}),"\n",(0,i.jsxs)(e.li,{children:["The ",(0,i.jsx)(e.code,{children:"run"})," method accepts a ",(0,i.jsx)(e.code,{children:"ChatInputInteractionContext"})," that holds contextual information on the command being\nexecuted, such as the original ",(0,i.jsx)(e.code,{children:"ChatInputInteractionEvent"}),", the ",(0,i.jsx)(e.code,{children:"MessageChannel"})," where the interaction happened,\nthe ",(0,i.jsx)(e.code,{children:"User"})," who initiated the interaction, and a ",(0,i.jsx)(e.code,{children:"Locale"})," that may have been adapted to the target user (\nsee ",(0,i.jsx)(e.a,{href:"/docs/interaction-library/filtering-and-adapting-events",children:"Filtering and adapting events"}),")."]}),"\n",(0,i.jsxs)(e.li,{children:["Events are automatically acknowledged by default, so you can directly call ",(0,i.jsx)(e.code,{children:"createFollowup()"})," without\nusing ",(0,i.jsx)(e.code,{children:"deferReply()"})," first (",(0,i.jsx)(e.code,{children:"reply()"})," will not work unless you disable automatic acknowledgment,\nsee ",(0,i.jsx)(e.a,{href:"/docs/interaction-library/acknowledging-interactions",children:"Acknowledging Interactions"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(e.admonition,{type:"info",children:[(0,i.jsxs)(e.p,{children:["If you are using the Botrino framework, you have nothing else to do, the command will be automatically recognized and\nregistered. Otherwise, you need to manually register it into the ",(0,i.jsx)(e.code,{children:"InteractionService"})," like this:"]}),(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"interactionService.registerChatInputCommand(new PingCommand());\n"})})]}),"\n",(0,i.jsx)(e.h3,{id:"command-options",children:"Command options"}),"\n",(0,i.jsxs)(e.p,{children:["A command may accept one or many options, whether they are required or optional. The library\nprovides ",(0,i.jsx)(e.code,{children:"ChatInputCommandGrammar"})," that allows to inject the option values into a record class that is going to\nbe instantiated when the command is executed. Here is an example of a command using options:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.ChatInputCommand;\nimport botrino.interaction.context.ChatInputInteractionContext;\nimport botrino.interaction.grammar.ChatInputCommandGrammar;\nimport botrino.interaction.listener.ChatInputInteractionListener;\nimport discord4j.core.object.command.ApplicationCommandOption;\nimport discord4j.discordjson.json.ApplicationCommandOptionData;\nimport org.reactivestreams.Publisher;\n\nimport java.util.List;\n\n@ChatInputCommand(name = "options", description = "Option testing")\npublic class OptionsCommand implements ChatInputInteractionListener {\n\n    private final ChatInputCommandGrammar<Options> grammar = ChatInputCommandGrammar.of(Options.class);\n\n    @Override\n    public Publisher<?> run(ChatInputInteractionContext ctx) {\n        return grammar.resolve(ctx.event()).flatMap(options -> ctx.event()\n                .createFollowup("Value of `my-string`: " + options.myString));\n    }\n\n    @Override\n    public List<ApplicationCommandOptionData> options() {\n        return grammar.toOptions();\n    }\n\n    private record Options(\n            @ChatInputCommandGrammar.Option(\n                    type = ApplicationCommandOption.Type.STRING,\n                    name = "my-string",\n                    description = "The string argument",\n                    required = true,\n                    choices = {\n                            @ChatInputCommandGrammar.Choice(name = "Choice 1", stringValue = "1"),\n                            @ChatInputCommandGrammar.Choice(name = "Choice 2", stringValue = "2"),\n                            @ChatInputCommandGrammar.Choice(name = "Choice 3", stringValue = "3")\n                    }\n            )\n            String myString) {}\n}\n'})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Create a record class that declares the fields in which you want to inject the option values. It is recommended to\nuse\nan internal private record for better code readability, unless you are re-using the same record for several commands."}),"\n",(0,i.jsxs)(e.li,{children:["Use the annotation ",(0,i.jsx)(e.code,{children:"@ChatInputCommandGrammar.Option"})," on each record parameter to declare the properties of the\noption (the type,\nthe name, the description, whether they are required or not, and the array of value choices, if any)."]}),"\n",(0,i.jsxs)(e.li,{children:["Create a new ",(0,i.jsx)(e.code,{children:"ChatInputCommandGrammar"})," and pass the class to the ",(0,i.jsx)(e.code,{children:".of()"})," method. You only need to instantiate once,\nrather than on each command execution."]}),"\n",(0,i.jsxs)(e.li,{children:["In the ",(0,i.jsx)(e.code,{children:"run(ChatInputInteractionContext)"})," method, call the ",(0,i.jsx)(e.code,{children:"resolve(ChatInputInteractionEvent)"})," method which will\nread the options, instantiate the record and inject the values in the annotated fields. You can then use the record\nobject to conveniently access the values, as shown in the example above."]}),"\n",(0,i.jsxs)(e.li,{children:["Override the ",(0,i.jsx)(e.code,{children:"options()"})," method from ",(0,i.jsx)(e.code,{children:"ChatInputInteractionListener"})," and make it\nreturn ",(0,i.jsx)(e.code,{children:"ChatInputCommandGrammar#toOptions()"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["For reference, here is a table associating each ",(0,i.jsx)(e.code,{children:"ApplicationCommandOption.Type"})," with the type of the field carrying the\nannotation:"]}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Option type"}),(0,i.jsx)(e.th,{children:"Type of annotated field"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"STRING"})}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"java.lang.String"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"INTEGER"})}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.code,{children:"java.lang.Long"})," (primitive ",(0,i.jsx)(e.code,{children:"long"})," may be used only if ",(0,i.jsx)(e.code,{children:"required = true"}),")"]})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"NUMBER"})}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.code,{children:"java.lang.Double"})," (primitive ",(0,i.jsx)(e.code,{children:"double"})," may be used only if ",(0,i.jsx)(e.code,{children:"required = true"}),")"]})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"BOOLEAN"})}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.code,{children:"java.lang.Boolean"})," (primitive ",(0,i.jsx)(e.code,{children:"boolean"})," may be used only if ",(0,i.jsx)(e.code,{children:"required = true"}),")"]})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"USER"})}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.code,{children:"discord4j.core.object.entity.User"})," (or ",(0,i.jsx)(e.code,{children:"discord4j.core.object.entity.Member"})," if in a guild)"]})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"CHANNEL"})}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"discord4j.core.object.entity.channel.Channel"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"ROLE"})}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"discord4j.core.object.entity.Role"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"MENTIONABLE"})}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"discord4j.common.util.Snowflake"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"ATTACHMENT"})}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"discord4j.core.object.entity.Attachment"})})]})]})]}),"\n",(0,i.jsx)(e.admonition,{type:"caution",children:(0,i.jsxs)(e.p,{children:["Optional options will be filled with ",(0,i.jsx)(e.code,{children:"null"})," if not specified by the user, which means you cannot use primitive types\nfor ",(0,i.jsx)(e.code,{children:"INTEGER"}),", ",(0,i.jsx)(e.code,{children:"NUMBER"})," and ",(0,i.jsx)(e.code,{children:"BOOLEAN"})," if ",(0,i.jsx)(e.code,{children:"required = false"}),", otherwise you will get ",(0,i.jsx)(e.code,{children:"NullPointerException"}),"s."]})}),"\n",(0,i.jsx)(e.admonition,{type:"info",children:(0,i.jsxs)(e.p,{children:["For legacy purposes, you can use a normal class instead of a record. In that case, the class must have a no-arg\nconstructor, and the ",(0,i.jsx)(e.code,{children:"@ChatInputCommandGrammar.Option"})," annotations should be on fields declared in the class. Using\nrecords is preferred as it allows for immutability."]})}),"\n",(0,i.jsx)(e.h3,{id:"subcommands-and-subcommand-groups",children:"Subcommands and subcommand groups"}),"\n",(0,i.jsx)(e.p,{children:"Discord allows to create subcommands and subcommand groups to help in organizing the logic of a complex command. Here is\nan example of a command using subcommands and subcommand groups:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'\n@ChatInputCommand(\n        name = "nest",\n        description = "Subcommand testing",\n        subcommands = {\n                @Subcommand(name = "sub1", description = "Subcommand 1", listener = NestCommand.Sub1.class),\n                @Subcommand(name = "sub2", description = "Subcommand 2", listener = NestCommand.Sub2.class)\n        },\n        subcommandGroups = {\n                @SubcommandGroup(name = "group1", description = "Group 1", subcommands = {\n                        @Subcommand(name = "sub", description = "Subcommand", listener = NestCommand.G1Sub.class)\n                })\n        }\n)\npublic final class NestCommand {\n\n    public static final class Sub1 implements ChatInputInteractionListener {\n\n        @Override\n        public Publisher<?> run(ChatInputInteractionContext ctx) {\n            return ctx.event().createFollowup("sub1: pong!");\n        }\n    }\n\n    public static final class Sub2 implements ChatInputInteractionListener {\n\n        @Override\n        public Publisher<?> run(ChatInputInteractionContext ctx) {\n            return ctx.event().createFollowup("sub2: pong!");\n        }\n    }\n\n    public static final class G1Sub implements ChatInputInteractionListener {\n\n        @Override\n        public Publisher<?> run(ChatInputInteractionContext ctx) {\n            return ctx.event().createFollowup("group1 sub: pong!");\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Here are the notable differences:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["The class carrying the ",(0,i.jsx)(e.code,{children:"@ChatInputCommand"})," annotation no longer implements ",(0,i.jsx)(e.code,{children:"ChatInputInteractionListener"}),". Indeed, as\nper Discord's documentation a base command becomes unusable if subcommands are present."]}),"\n",(0,i.jsxs)(e.li,{children:["The ",(0,i.jsx)(e.code,{children:"@ChatInputCommand"})," specifies an array of ",(0,i.jsx)(e.code,{children:"@Subcommand"})," and ",(0,i.jsx)(e.code,{children:"@SubcommandGroup"})," with their own name and\ndescription."]}),"\n",(0,i.jsxs)(e.li,{children:["Subcommands specify the class implementing ",(0,i.jsx)(e.code,{children:"ChatInputInteractionListener"})," that is going to handle them. In this\nexample they are internal classes, but they can as well be external."]}),"\n"]}),"\n",(0,i.jsxs)(e.admonition,{type:"info",children:[(0,i.jsxs)(e.p,{children:["Here is how you manually register a command containing subcommands when you control the instance\nof ",(0,i.jsx)(e.code,{children:"InteractionService"}),":"]}),(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"interactionService.registerChatInputCommand(new NestCommand(),List.\n\nof(\n        new NestCommand.Sub1(),\n        new NestCommand.\n\nSub2(),\n        new NestCommand.\n\nG1Sub()\n));\n"})})]}),"\n",(0,i.jsx)(e.admonition,{type:"caution",children:(0,i.jsxs)(e.p,{children:["If you are using the Botrino framework, the subcommand classes must either have a public no-arg constructor or be\ndeclared as a service. If the classes are internal, they must be ",(0,i.jsx)(e.code,{children:"static"}),"."]})}),"\n",(0,i.jsx)(e.h2,{id:"context-menu-commands",children:"Context menu commands"}),"\n",(0,i.jsxs)(e.p,{children:["Discord currently support two types of context menu commands, one on messages and one on users. It works the same as\nchat input commands, but you need to use the ",(0,i.jsx)(e.code,{children:"@MessageCommand"})," and ",(0,i.jsx)(e.code,{children:"@UserCommand"})," annotations with\nthe ",(0,i.jsx)(e.code,{children:"MessageInteractionListener"})," and ",(0,i.jsx)(e.code,{children:"UserInteractionListener"})," interfaces, respectively."]}),"\n",(0,i.jsx)(e.p,{children:"Context menu commands are actually less complex than chat input ones, since there is no description, no options, no\nsubcommands... Only a name and a run method:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.UserCommand;\nimport botrino.interaction.context.UserInteractionContext;\nimport botrino.interaction.listener.UserInteractionListener;\nimport org.reactivestreams.Publisher;\n\n@UserCommand("Fight")\npublic final class FightCommand implements UserInteractionListener {\n\n    @Override\n    public Publisher<?> run(UserInteractionContext ctx) {\n        return ctx.event().createFollowup("You are fighting <@" +\n                ctx.event().getTargetId().asString() + ">");\n    }\n}\n'})}),"\n",(0,i.jsxs)(e.admonition,{type:"info",children:[(0,i.jsxs)(e.p,{children:["If you need to do manual registration, it happens\nvia ",(0,i.jsx)(e.code,{children:"InteractionService#registerMessageCommand(MessageInteractionListener)"}),"\nand ",(0,i.jsx)(e.code,{children:"InteractionService#registerUserCommand(MessageInteractionListener)"}),":"]}),(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"interactionService.registerUserCommand(new FightCommand());\n"})})]}),"\n",(0,i.jsx)(e.h2,{id:"commands-as-a-service",children:"Commands as a service"}),"\n",(0,i.jsx)(e.admonition,{type:"info",children:(0,i.jsxs)(e.p,{children:["The following is only applicable if you are using the Botrino framework.\nSee ",(0,i.jsx)(e.a,{href:"/docs/api/working-with-services",children:"Working with services"}),"."]})}),"\n",(0,i.jsxs)(e.p,{children:["Classes implementing commands can themselves be declared as services without any issues. For example if you need to\naccess the ",(0,i.jsx)(e.code,{children:"ConfigContainer"})," in your command, you can do this:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.api.config.ConfigContainer;\nimport botrino.api.config.object.BotConfig;\nimport botrino.interaction.annotation.ChatInputCommand;\nimport botrino.interaction.context.ChatInputInteractionContext;\nimport botrino.interaction.listener.ChatInputInteractionListener;\nimport com.github.alex1304.rdi.finder.annotation.RdiFactory;\nimport com.github.alex1304.rdi.finder.annotation.RdiService;\nimport discord4j.gateway.intent.IntentSet;\nimport org.reactivestreams.Publisher;\n\n@RdiService\n@ChatInputCommand(name = "intents", description = "Displays the intents enabled for this bot.")\npublic final class IntentsCommand implements ChatInputInteractionListener {\n\n    private final long intents;\n\n    @RdiFactory\n    public IntentsCommand(ConfigContainer configContainer) {\n        this.intents = configContainer.get(BotConfig.class)\n                .enabledIntents()\n                .orElse(IntentSet.nonPrivileged().getRawValue());\n    }\n\n    @Override\n    public Publisher<?> run(ChatInputInteractionContext ctx) {\n        return ctx.event().createFollowup("Intents enabled: " + intents);\n    }\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["The command above accesses the values in the ",(0,i.jsx)(e.code,{children:"config.json"})," to get the gateway intents enabled for the bot. You can\nnotice the use of ",(0,i.jsx)(e.code,{children:"@RdiService"})," on top of ",(0,i.jsx)(e.code,{children:"@ChatInputCommand"}),", this works totally fine! Don't forget the ",(0,i.jsx)(e.code,{children:"@RdiFactory"}),"\nto inject the configuration container, and you're ready to run the bot and try out this command."]}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsxs)(e.p,{children:["If you declare a command as a service this way, you are allowed to do anything with it like any other service, for\nexample inject it in other services, or set up ",(0,i.jsx)(e.code,{children:"@RdiFactory"})," to be\na ",(0,i.jsx)(e.a,{href:"/docs/api/working-with-services#injecting-a-service-in-a-reactive-static-factory",children:"reactive static method"})," in case the\ncommand needs to perform a reactive task in order to be initialized."]})})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);