"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[812],{1877:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var o=t(4848),i=t(8453),a=t(6025);const r={title:"Dealing with components"},s=void 0,c={id:"interaction-library/dealing-with-components",title:"Dealing with components",description:"The library offers two ways to handle interactions with message components (buttons and select menus).",source:"@site/docs/interaction-library/dealing-with-components.mdx",sourceDirName:"interaction-library",slug:"/interaction-library/dealing-with-components",permalink:"/docs/interaction-library/dealing-with-components",draft:!1,unlisted:!1,editUrl:"https://github.com/Alex1304/botrino/edit/main/website/docs/interaction-library/dealing-with-components.mdx",tags:[],version:"current",frontMatter:{title:"Dealing with components"},sidebar:"someSidebar",previous:{title:"Acknowledging interactions",permalink:"/docs/interaction-library/acknowledging-interactions"},next:{title:"Privileges",permalink:"/docs/interaction-library/privileges"}},l={},d=[{value:"Handling component interactions as regular commands",id:"handling-component-interactions-as-regular-commands",level:2},{value:"Waiting for component interactions inside a command",id:"waiting-for-component-interactions-inside-a-command",level:2},{value:"Pagination system with components",id:"pagination-system-with-components",level:2}];function m(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"The library offers two ways to handle interactions with message components (buttons and select menus)."}),"\n",(0,o.jsx)(n.h2,{id:"handling-component-interactions-as-regular-commands",children:"Handling component interactions as regular commands"}),"\n",(0,o.jsxs)(n.p,{children:["The first way is to treat component interactions as regular commands, which consists of declaring a listener that is\ngoing to be called every time a component with a specific ",(0,o.jsx)(n.code,{children:"customId"})," is interacted with. The structure is similar\nto ",(0,o.jsx)(n.a,{href:"/docs/interaction-library/creating-commands",children:"creating commands"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.ComponentCommand;\nimport botrino.interaction.context.ButtonInteractionContext;\nimport botrino.interaction.listener.ComponentInteractionListener;\nimport org.reactivestreams.Publisher;\n\n@ComponentCommand("clickme")\npublic final class ClickMeButtonCommand implements ComponentInteractionListener<Void> {\n\n    @Override\n    public Publisher<Void> run(ButtonInteractionContext ctx) {\n        return ctx.event().createFollowup("Button clicked!").then();\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The class implements ",(0,o.jsx)(n.code,{children:"ComponentInteractionListener<Void>"})," and overrides ",(0,o.jsx)(n.code,{children:"run(ButtonInteractionContext)"})," (it has\nseveral ",(0,o.jsx)(n.code,{children:"run()"})," overloads, one for each type of component, here we want a button. For select menus you're supposed to\noverride ",(0,o.jsx)(n.code,{children:"run(SelectMenuInteractionContext)"}),"). The ",(0,o.jsx)(n.code,{children:"@ComponentCommand"})," annotation specifies the customId to listen for.\nLet's make a chat input command to create the message containing the button:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.ChatInputCommand;\nimport botrino.interaction.context.ChatInputInteractionContext;\nimport botrino.interaction.listener.ChatInputInteractionListener;\nimport discord4j.core.object.component.ActionRow;\nimport discord4j.core.object.component.Button;\nimport org.reactivestreams.Publisher;\n\n@ChatInputCommand(name = "create-button", description = "Create a button.")\npublic final class CreateButtonCommand implements ChatInputInteractionListener {\n\n    @Override\n    public Publisher<?> run(ChatInputInteractionContext ctx) {\n        return ctx.event().createFollowup("Click the button:")\n                .withComponents(ActionRow.of(\n                        Button.primary("clickme", "Click me!")));\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"As usual, unless you are using the Botrino framework, you need to register them manually:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"interactionService.registerComponentCommand(new ClickMeButtonCommand());\ninteractionService.registerChatInputCommand(new CreateButtonCommand());\n"})}),"\n",(0,o.jsx)(n.p,{children:"Result:"}),"\n",(0,o.jsx)("img",{src:(0,a.A)("img/clickme.png"),alt:""}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"@ComponentCommand"})," annotation is in fact not required if you aren't using the Botrino framework. You may as well\noverride the ",(0,o.jsx)(n.code,{children:"customId()"})," method from ",(0,o.jsx)(n.code,{children:"ComponentInteractionListener"}),". The annotation is still required when using the\nBotrino framework, as it will only auto-register listeners containing that annotation, but if you are already\noverriding ",(0,o.jsx)(n.code,{children:"customId()"})," you can use ",(0,o.jsx)(n.code,{children:"@ComponentCommand"})," alone without the value. An example might be more clear:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.ComponentCommand;\nimport botrino.interaction.context.ButtonInteractionContext;\nimport botrino.interaction.listener.ComponentInteractionListener;\nimport org.reactivestreams.Publisher;\n\n@ComponentCommand // You may omit the customId here...\npublic final class ClickMeButtonCommand implements ComponentInteractionListener<Void> {\n    \n    @Override\n    public String customId() {\n        return "clickme"; // ...if you specify it here instead\n    }\n\n    @Override\n    public Publisher<Void> run(ButtonInteractionContext ctx) {\n        return ctx.event().createFollowup("Button clicked!").then();\n    }\n}\n'})})]}),"\n",(0,o.jsx)(n.h2,{id:"waiting-for-component-interactions-inside-a-command",children:"Waiting for component interactions inside a command"}),"\n",(0,o.jsxs)(n.p,{children:['In many cases, you want to use components as a way to make your commands more interactive, for example if you need\nconfirmation from the user to perform an action. You would need some way to "pause" the execution of your command and\nresume when the user has given a response by clicking a button or a select menu. This is made easy with\nthe ',(0,o.jsx)(n.code,{children:"awaitButtonClick(customId)"})," and ",(0,o.jsx)(n.code,{children:"awaitSelectMenuItems(customId)"})," methods. Here's an example of a simple command\nwaiting for the user to select an item and display the value clicked:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.ChatInputCommand;\nimport botrino.interaction.context.ChatInputInteractionContext;\nimport botrino.interaction.listener.ChatInputInteractionListener;\nimport discord4j.core.object.component.ActionRow;\nimport discord4j.core.object.component.SelectMenu;\nimport discord4j.core.object.entity.Message;\nimport discord4j.core.spec.InteractionFollowupCreateSpec;\nimport org.reactivestreams.Publisher;\nimport reactor.core.publisher.Mono;\n\nimport java.util.UUID;\n\nimport static botrino.interaction.listener.ComponentInteractionListener.selectMenu;\n\n@ChatInputCommand(name = "select", description = "Command for testing select menus")\npublic class SelectCommand implements ChatInputInteractionListener {\n\n    @Override\n    public Publisher<?> run(ChatInputInteractionContext ctx) {\n        final var customId = UUID.randomUUID().toString();\n        return ctx.event().createFollowup("Select an option:")\n                .withComponents(ActionRow.of(SelectMenu.of(customId,\n                        SelectMenu.Option.of("option 1", "foo"),\n                        SelectMenu.Option.of("option 2", "bar"),\n                        SelectMenu.Option.of("option 3", "baz"))))\n                .map(Message::getId)\n                // Wait until the select menu is interacted with and return the value clicked\n                .flatMap(messageId -> ctx.awaitSelectMenuItems(customId)\n                        .flatMap(items -> ctx.event().createFollowup("You clicked: " + items.get(0))\n                                .then(ctx.event().deleteFollowup(messageId))));\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Since you want to listen for one specific select menu (and not all select menus with some customId), you generate a\ncustomId that is unique for each invocation of the ",(0,o.jsx)(n.code,{children:"/select"})," command. You can easily generate a random string\nvia ",(0,o.jsx)(n.code,{children:"java.util.UUID"}),"."]}),"\n",(0,o.jsx)(n.li,{children:"A first followup is sent with the message containing the select menu."}),"\n",(0,o.jsxs)(n.li,{children:["Once the message has been sent, call ",(0,o.jsx)(n.code,{children:"awaitSelectMenuItems(customId)"})," with the same customId generated previously. It\nwill wait for the user to interact with the menu and will emit the value clicked."]}),"\n",(0,o.jsx)(n.li,{children:"The value received is then displayed via a new followup message."}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["If you don't make the customId unique on each run, there will be conflicts when the ",(0,o.jsx)(n.code,{children:"/select"})," command is run several\ntimes consecutively by the same user in the same channel."]})}),"\n",(0,o.jsxs)(n.p,{children:["Here is another example with ",(0,o.jsx)(n.code,{children:"awaitButtonClick(customId)"})," that asks the user to confirm when resetting a user's\nnickname:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.UserCommand;\nimport botrino.interaction.context.UserInteractionContext;\nimport botrino.interaction.listener.UserInteractionListener;\nimport discord4j.core.object.component.ActionRow;\nimport discord4j.core.object.component.Button;\nimport discord4j.core.object.entity.Message;\nimport org.reactivestreams.Publisher;\nimport reactor.core.publisher.Mono;\n\nimport java.util.UUID;\n\nimport static botrino.interaction.listener.ComponentInteractionListener.button;\n\n@UserCommand("Reset Nickname")\npublic class ResetNickCommand implements UserInteractionListener {\n\n    @Override\n    public Publisher<?> run(UserInteractionContext ctx) {\n        final var guildId = ctx.event().getInteraction().getGuildId().orElse(null);\n        if (guildId == null) {\n            return ctx.event().createFollowup("Cannot use outside of a guild");\n        }\n        final var yesId = UUID.randomUUID().toString();\n        final var noId = UUID.randomUUID().toString();\n        return ctx.event().createFollowup("Reset the nickname of that user?")\n                .withComponents(ActionRow.of(\n                        Button.primary(yesId, "Yes"),\n                        Button.secondary(noId, "No")))\n                .map(Message::getId)\n                .flatMap(messageId -> Mono.firstWithValue(\n                                ctx.awaitButtonClick(yesId),\n                                ctx.awaitButtonClick(noId))\n                        .flatMap(buttonClicked -> buttonClicked.equals(yesId) ? ctx.event()\n                                .getClient()\n                                .getMemberById(guildId, ctx.event().getTargetId())\n                                .flatMap(member -> member.edit().withNicknameOrNull(null))\n                                .then(ctx.event().createFollowup("Nickname reset successful!"))\n                                : ctx.event().createFollowup("Action cancelled"))\n                        .then(ctx.event().deleteFollowup(messageId)));\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:['The code is quite self-explanatory: we display two buttons, one for "yes" and one for "no". We use ',(0,o.jsx)(n.code,{children:"Mono.firstWithValue"}),"\nto only wait for the first click on either of the two buttons, and depending on which button was clicked, we execute one\nor the other action."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["There exists a more generic method ",(0,o.jsx)(n.code,{children:"awaitComponentInteraction"})," that lets you manipulate the underlying interaction\ncontext before returning a value. It accepts a ",(0,o.jsx)(n.code,{children:"ComponentInteractionListener<R>"})," that you can construct via its static\nmethods ",(0,o.jsx)(n.code,{children:"button(String, Function)"})," and ",(0,o.jsx)(n.code,{children:"selectMenu(String, Function)"}),", each accepting the customId and a function\nreceiving a ",(0,o.jsx)(n.code,{children:"ButtonInteractionContext"})," or ",(0,o.jsx)(n.code,{children:"SelectMenuInteractionContext"})," and producing a value of any type."]})}),"\n",(0,o.jsx)(n.h2,{id:"pagination-system-with-components",children:"Pagination system with components"}),"\n",(0,o.jsxs)(n.p,{children:["Making a pagination system is one of the most obvious use cases for message components. The library provides a static\nmethod ",(0,o.jsx)(n.code,{children:"MessagePaginator::paginate"})," to build paginated messages easily. See the example below:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'package testbot1;\n\nimport botrino.interaction.annotation.ChatInputCommand;\nimport botrino.interaction.context.ChatInputInteractionContext;\nimport botrino.interaction.listener.ChatInputInteractionListener;\nimport botrino.interaction.util.MessagePaginator;\nimport discord4j.core.object.component.ActionRow;\nimport discord4j.core.object.component.Button;\nimport discord4j.core.spec.MessageCreateSpec;\nimport org.reactivestreams.Publisher;\nimport reactor.core.publisher.Mono;\n\n@ChatInputCommand(name = "paginate", description = "Pagination testing")\npublic final class PaginateCommand implements ChatInputInteractionListener {\n\n    @Override\n    public Publisher<?> run(ChatInputInteractionContext ctx) {\n        return MessagePaginator.paginate(ctx, 5, state -> Mono.just(MessageCreateSpec.create()\n                .withContent("Page " + (state.getPage() + 1) + "/" + state.getPageCount())\n                .withComponents(ActionRow.of(\n                        state.previousButton(customId -> Button.secondary(customId, "<< Previous")),\n                        state.nextButton(customId -> Button.secondary(customId, "Next >>")),\n                        state.closeButton(customId -> Button.danger(customId, "Close"))\n                ))));\n    }\n}\n'})}),"\n",(0,o.jsx)("img",{src:(0,a.A)("img/paginate.png"),alt:""}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"paginate"})," method takes 3 arguments. The first one is the interaction context, the second one is the total number\nof pages, and the last one is a function that receives a state and produces the message to display. An overload exists\nallowing you to specify the initial page number (by default it starts at the first page)."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"state"})," holds information on the current state of the paginator, such as the current page number and whether it is\nactive"]}),"\n",(0,o.jsx)(n.li,{children:"To render the buttons, the state exposes three methods to build previous, next and close buttons respectively. The\nstate object controls whether the buttons are enabled or disabled according to whether we are at first page (in which\ncase previous button should be disabled), at last page (in which case next button should be disabled), or if the\npaginator has already closed, in which case all buttons should be disabled."}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["The paginator automatically closes as per the ",(0,o.jsx)(n.code,{children:"await_component_timeout_seconds"})," value defined in\nthe ",(0,o.jsx)(n.a,{href:"/docs/interaction-library/configuration",children:"configuration"}),"."]})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var o=t(6540);const i={},a=o.createContext(i);function r(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);